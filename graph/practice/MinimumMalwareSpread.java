package graph.practice;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class MinimumMalwareSpread {

  static class ComponentInfo {
    int size;
    List<Integer> initialInfectedNodes;

    ComponentInfo() {
      this.size = 0;
      this.initialInfectedNodes = new ArrayList<>();
    }

    ComponentInfo(int size, List<Integer> initialInfectedNodes) {
      this.size = size;
      this.initialInfectedNodes = initialInfectedNodes;
    }
  }


  private static int minMalwareSpread(int n, int edges, int[] from, int[] to, int[] malware) {

    // build a graph
    // find the no. of connected components
    // for each connected component keep track of the no. of nodes, the initial infected nodes and the size of the component
    // for each connected component count the no. of initial infected nodes, if the no. of initial infected node is 1 then that node is responsible for infecting the entire component
    // Among all the connected components with exactly one initial infected node, select the one with the maximum size
    // If there is a tie in the maximum size select the node with the smallest index
    // If no such component exists that have exactly one initial infected node then remove the infected node with the smallest index


    Map<Integer, Set<Integer>> graph = new HashMap<>();
    for (int i=1; i<=n; i++) {
      graph.put(i, new HashSet<>());
    }
    for (int i=0; i<edges; i++) {
      int u = from[i];
      int v = to[i];
      graph.get(u).add(v);
      graph.get(v).add(u);
    }

    Set<Integer> visited = new HashSet<>();
    // keeps track of which nodes connected to which component
    Map<Integer, Integer> nodeToComponentId = new HashMap<>();
    // keeps track of the size and the no. of initial infected nodes in a component
    Map<Integer, ComponentInfo> componentIdToComponentInfo = new HashMap<>();

    int componentId = 1;

    for (int i=1; i<=n; i++) {
      if (!visited.contains(i)) {
        ComponentInfo componentInfo = new ComponentInfo();
        dfs(i, visited, graph, componentId, nodeToComponentId, malware, componentInfo);
        componentIdToComponentInfo.put(componentId, componentInfo);
        componentId++;
      }
    }

    int maxSize = 0, minNode = 0;
    List<Integer> infectedNodes = new ArrayList<>();
    for (int i=0; i<n; i++) {
      if (malware[i] == 1) {
        infectedNodes.add(i+1);
      }
    }
//    Collections.sort(infectedNodes);

    for (int node : infectedNodes) {
      int cmpId = nodeToComponentId.get(node);
      ComponentInfo componentInfo = componentIdToComponentInfo.get(cmpId);
      int size = componentInfo.size;
      List<Integer> initialInfectedNodes = componentInfo.initialInfectedNodes;
      // if the initial infected node is 1 then this node is responsible for infecting this entire component
      if (initialInfectedNodes.size() == 1) {
        if (size > maxSize) {
          maxSize = size;
          minNode = node;
        } else if (size == maxSize && node < minNode) {
          minNode = node;
        }
      }
    }

    // if there are no such components with exactly one initial infected node then return the node with the smallest index
    if (minNode == 0 && infectedNodes.size() > 0) {
      minNode = infectedNodes.get(0);
    }

    return minNode;
  }


  private static void dfs(int node, Set<Integer> visited, Map<Integer, Set<Integer>> graph, int componentId, Map<Integer, Integer> nodeToComponentId, int[] malware, ComponentInfo componentInfo) {

    visited.add(node);
    nodeToComponentId.put(node, componentId);
    componentInfo.size++;
    // check if the node is infected or not
    if (malware[node-1] == 1) {
      componentInfo.initialInfectedNodes.add(node);
    }
    Set<Integer> neighbors = graph.get(node);
    for (int neighbor : neighbors) {
      if (!visited.contains(neighbor)) {
        dfs(neighbor, visited, graph, componentId, nodeToComponentId, malware, componentInfo);
      }
    }
  }

  public static void main(String[] args) {
    int n = 5, edges = 4;
    int[] from = {1,2,3,4};
    int[] to = {2,3,4,5};
    int[] malware = {1, 1, 1, 1, 1};

    System.out.println(minMalwareSpread(n, edges, from, to, malware));
  }
}
